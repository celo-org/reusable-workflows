---
name: 'Terraform plan'
on:
  workflow_call:
    inputs:
      workload-id-provider:
        required: true
        type: string
      service-account:
        required: true
        type: string
      akeyless-api-gateway:
        required: false
        type: string
      akeyless-github-access-id:
        required: false
        type: string
      working-dir:
        required: true
        type: string
      token-format:
        required: false
        type: string
      access-token-scopes:
        required: false
        type: string
      timeout-minutes:
        default: 30
        type: number
        description: "Workflow timeout"
      environment:
        default: ''
        description: "Deployment environment in github"
        type: string
      debug_enabled:
        default: false
        required: false
        type: boolean
        description: "run tmate for troubleshooting"
      runs_on:
        default: "['self-hosted', 'org', 'terraform']"
        type: string
        description: "github runner tags"
      pr-comment:
        default: true
        type: boolean        
      summary:
        default: true
        type: boolean

jobs:
  terraform:
    runs-on: ${{ fromJson(inputs.runs_on) }}
    timeout-minutes: ${{ inputs.timeout-minutes }}
    defaults:
      run:
        working-directory: ${{ inputs.working-dir }}
        shell: bash
    steps:
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@e5c7151931ca95bad1c6f4190c730ecf8c7dde48
        if: inputs.debug_enabled == true 
        with:
          detached: true
          limit-access-to-actor: true

      # Security policies go-tests and go-tests-debug are configured in step security app
      # Policy can be seen here https://app.stepsecurity.io/github/celo-org/actions/policies
      # disable-sudo is set to false if debug is true, because tmate requires root to work.
      - name: Harden Runner
        if: runner.environment == 'github-hosted'
        uses: step-security/harden-runner@v2
        with:
          egress-policy: audit       

      - name: 'Checkout'
        uses: actions/checkout@v4

      # Akeyless Get Secrets will take the specified dynamic or static secrets and set them to their corresponding environment variables.  It will also
      # export github's JWT Token as AKEYLESS_AUTH_JWT (which their terraform provider uses for JWT authentication, and AUTH_TOKEN - The akeyless auth token
      # it gets back after authenticating, which can be used for certain things (such as ansible)
      - name: Akeyless Get Secrets
        id: get_auth_token
        uses: docker://us-west1-docker.pkg.dev/devopsre/akeyless-public/akeyless-action:latest
        with:
          api-url: ${{ inputs.akeyless-api-gateway }}
          access-id: ${{ inputs.akeyless-github-access-id }}

      # Uses Google workload identity federation to authenticate without keys, in security circle project.  Variables defined in security circle
      - id: 'auth'
        name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: ${{ inputs.workload-id-provider }}
          service_account: ${{ inputs.service-account }}
          token_format: ${{ inputs.token-format }}
          access_token_scopes: ${{ inputs.access-token-scopes }}
          access_token_lifetime: '20m'

      - name: Run Trivy vulnerability scanner
        uses: celo-org/trivy-composite-action@v1.0.1-alvaro
        with:
          scan-type: 'fs'
          scan-ref: ${{ inputs.working-dir }}
          pr-comment: ${{ inputs.pr-comment }}
          summary: ${{ inputs.summary }}

      - name: set terraform variables
        shell: bash
        run: echo "TF_VAR_google_credentials=${{ steps.auth.outputs.access_token }}" >> $GITHUB_ENV

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: true

      - name: Terraform Init
        id: init
        run: terraform init
        shell: bash

      - name: Terraform Format
        id: fmt
        run: terraform fmt -check
        shell: bash

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color
        shell: bash

      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -input=false -out=tfplan "-detailed-exitcode"
        shell: bash

      # Show Plan is used so we can get rid of all the "refreshing" comments that are noisy
      - name: Terraform Show Plan
        id: showplan
        run: terraform show tfplan "-no-color"
        continue-on-error: true
        shell: bash

      # Print the plan to file in this way to avoid problems with "'" in the plan
      - name: Print plan to file
        if: steps.plan.outputs.exitcode != '0'
        run: |
            cat > plan_temporal.txt <<'EOF'
            ${{ steps.showplan.outputs.stdout }}
            EOF
        shell: bash

      # Removes the refreshing from the plan output and then moves the + and - all the way
      # to the left of the pull request to trigger github's colors
      - name: Reformat Plan
        if: steps.plan.outputs.exitcode != '0'
        run: |
            sed -E 's/^([[:space:]]+)([-+])/\2\1/g' plan_temporal.txt > plan.txt
        shell: bash

      # Saves the plan in an environment variable so we can pull it back out
      - name: Put Plan in Env Var
        shell: bash
        if: steps.plan.outputs.exitcode != '0'
        run: |
          PLAN=$(cat plan.txt)
          check=${#PLAN}
          # Delimiting plan size to avoid error "Argument list too long" when posting the plan
          if [ "$check" -ge 65000 ];
          then
            PLAN='Terraform plan is too long to be posted in the PR comment. Please check the Action run to verify it'
          fi
          echo "$PLAN"
          {
              echo "PLAN<<EOF"
              echo "$PLAN"
              echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Post Plan to GitHub PR
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2
        if: github.event_name == 'pull_request' && steps.plan.outputs.exitcode != '0' && inputs.pr-comment == true
        env:
          WORKDIR: ${{ inputs.working-dir }}
        with:
          allow-repeats: true
          repo-token: ${{ github.token }}
          message-id: Plan ${{ env.WORKDIR }}
          message: |
            ### Terraform for ${{ env.WORKDIR }}
            #### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            <details><summary>Validation Output</summary>

            ```diff
            ${{ steps.validate.outputs.stdout }}
            ```
            </details>

            #### Terraform Plan üìñ\`${{ steps.plan.outcome }}\`

            <details><summary>Show Plan</summary>

            ```diff
            ${{ env.PLAN }}
            ```

            </details>

            *Pusher: @${{ github.actor }}*
            *Action: ${{ github.event_name }}*
            *Working Directory: ${{ env.WORKDIR }}*
            *Workflow: ${{ github.workflow }}*
            *Execution link: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}*

      - name: Terraform Apply
        id: apply
        if: github.ref_name == github.event.repository.default_branch && github.event_name == 'push' && steps.plan.outcome == 'success'
        shell: bash
        run: terraform apply -no-color -auto-approve "tfplan"

      - name: Build Report
        if: always() && github.ref_name == github.event.repository.default_branch && steps.apply.outputs.stdout != '' && ( inputs.summary || inputs.pr-comment ) && steps.plan.outputs.exitcode != '0'
        id: build-report
        shell: bash
        env:
          APPLY: "${{ steps.apply.outputs.stdout }}"
          WORKDIR: "${{ inputs.working-dir }}"
        run: |
          echo '${{ env.APPLY }}' > apply.txt
          {
              echo "### Terraform for ${{ env.WORKDIR }}"
              echo "#### Terraform Apply ${{ steps.apply.outcome }}"
              echo "<details><summary>Show Apply</summary>"
              echo ""
              echo '```'
              cat apply.txt
              echo '```'
              echo "</details>"
              echo ""
              echo "*Pusher: @${{ github.actor }}* \\"
              echo "*Action: ${{ github.event_name }}* \\"
              echo "*Working Directory: ${{ env.WORKDIR }}* \\"
              echo "*Workflow: ${{ github.workflow }}* \\"
              echo "*Execution link: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}* \\"
          } > 'report.txt'
          echo "report=report.txt" >> $GITHUB_OUTPUT     

      - name: Post Scan Results to GitHub PR
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2 
        if: always() && github.ref_name == github.event.repository.default_branch && inputs.pr-comment && steps.build-report.outputs.report != '' && steps.plan.outputs.exitcode != '0'
        with:
          allow-repeats: true
          repo-token: ${{ github.token }}
          message-id: Terraform Apply ${{ github.workflow }}
          message-path: "${{ inputs.working-dir }}/${{ steps.build-report.outputs.report }}"

      - name: Post Scan Results to Workflow Summary
        if: always() && github.ref_name == github.event.repository.default_branch && inputs.summary && steps.build-report.outputs.report != '' && steps.plan.outputs.exitcode != '0'
        shell: bash
        run: |
          while IFS= read -r line; do
            echo $line >> $GITHUB_STEP_SUMMARY
          done < "${{ steps.build-report.outputs.report }}"
